---
phase: 02-hook-observers
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/hive-recall-error.js
  - hooks/hive-recall-compact.js
  - hooks/hive-recall-session.js
autonomous: true

must_haves:
  truths:
    - "After a tool fails in a Hive project, a tool_error event appears in events.jsonl with tool name and error message"
    - "User interrupts (is_interrupt=true) do NOT produce tool_error events"
    - "When context compaction fires in a Hive project, a context_compaction event is recorded with trigger type"
    - "When a session starts, a session_boundary event with action='start' and session_type is recorded"
    - "When a session ends, a session_boundary event with action='end', reason, events_count, and agents_spawned is recorded"
    - "Non-Hive projects (no .planning/ directory) do NOT produce tool_error, context_compaction, or session_boundary events"
    - "All 3 hooks fail silently on any error (malformed input, disk error, missing files)"
  artifacts:
    - path: "hooks/hive-recall-error.js"
      provides: "PostToolUseFailure observer that writes tool_error events"
      contains: "tool_error"
      min_lines: 25
    - path: "hooks/hive-recall-compact.js"
      provides: "PreCompact observer that writes context_compaction events"
      contains: "context_compaction"
      min_lines: 25
    - path: "hooks/hive-recall-session.js"
      provides: "SessionStart + SessionEnd observer that writes session_boundary events"
      contains: "session_boundary"
      min_lines: 40
  key_links:
    - from: "hooks/hive-recall-error.js"
      to: ".planning/telemetry/events.jsonl"
      via: "fs.appendFileSync direct write"
      pattern: "appendFileSync"
    - from: "hooks/hive-recall-compact.js"
      to: ".planning/telemetry/events.jsonl"
      via: "fs.appendFileSync direct write"
      pattern: "appendFileSync"
    - from: "hooks/hive-recall-session.js"
      to: ".planning/telemetry/events.jsonl"
      via: "fs.appendFileSync direct write on both start and end"
      pattern: "appendFileSync"
    - from: "hooks/hive-recall-session.js"
      to: "process.argv[2]"
      via: "CLI argument determines start vs end mode"
      pattern: "process\\.argv\\[2\\]"
---

<objective>
Create the remaining 3 hook observer scripts (error, compaction, session) that passively capture tool errors, context compaction events, and session boundaries to events.jsonl.

Purpose: Completes the passive observation layer so all 5 Claude Code lifecycle events are captured without any workflow modifications.
Output: 3 new hook files following the exact pattern established by hive-recall-agent.js in Plan 01.
</objective>

<execution_context>
@./.claude/hive/workflows/execute-plan.md
@./.claude/hive/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-hook-observers/02-RESEARCH.md
@.planning/phases/02-hook-observers/02-01-SUMMARY.md
@hooks/hive-recall-agent.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostToolUseFailure and PreCompact hook observers</name>
  <files>hooks/hive-recall-error.js, hooks/hive-recall-compact.js</files>
  <action>
**Create hooks/hive-recall-error.js (PostToolUseFailure observer):**

Follow the EXACT same pattern as hive-recall-agent.js (read it first for the established pattern). The hook:

1. Shebang: `#!/usr/bin/env node`
2. Header: `// Hive Recall -- Tool error observer` and `// Hook: PostToolUseFailure | Fail-silent`
3. Reads JSON from stdin (same data/end pattern)
4. Entire body in try/catch with EMPTY catch (HOOK-06)
5. HOOK-07 filtering: Since PostToolUseFailure has NO agent context, filter by project-level check: `fs.existsSync(path.join(data.cwd, '.planning'))`. If .planning/ does not exist, return early (not a Hive project).
6. Config check: same pattern as hive-recall-agent.js (read .planning/config.json, check telemetry?.enabled and telemetry?.hooks)
7. Skip user interrupts: `if (data.is_interrupt) return;` -- interrupts are not real errors
8. Build event envelope:
   ```
   {
     ts: new Date().toISOString(),
     session: data.session_id || 'unknown',
     type: 'tool_error',
     v: 1,
     data: {
       tool: data.tool_name || 'unknown',
       command: data.tool_input?.command || null,  // For Bash tool errors
       error: data.error || 'unknown error'
     }
   }
   ```
9. mkdirSync + appendFileSync (same pattern)

Do NOT try to access `data.agent_type` or `data.agent` -- PostToolUseFailure does not provide these fields.

**Create hooks/hive-recall-compact.js (PreCompact observer):**

Same pattern. The hook:

1. Shebang + header: `// Hive Recall -- Context compaction observer` and `// Hook: PreCompact | Fail-silent`
2. stdin parsing, try/catch, HOOK-07 (.planning/ check), config check -- all same pattern
3. Build event envelope:
   ```
   {
     ts: new Date().toISOString(),
     session: data.session_id || 'unknown',
     type: 'context_compaction',
     v: 1,
     data: {
       trigger: data.trigger || 'unknown',  // "manual" or "auto"
       custom_instructions: data.custom_instructions || null
     }
   }
   ```
4. mkdirSync + appendFileSync

Do NOT try to access `data.remaining_pct` or token counts -- PreCompact does not provide these. Only `trigger` and `custom_instructions` are available.
  </action>
  <verify>
1. `node -c hooks/hive-recall-error.js` passes syntax check
2. `node -c hooks/hive-recall-compact.js` passes syntax check
3. `echo '{"session_id":"s1","cwd":"/tmp","tool_name":"Bash","error":"command failed","is_interrupt":false}' | node hooks/hive-recall-error.js; echo $?` exits 0
4. `echo '{"session_id":"s1","cwd":"/tmp","tool_name":"Bash","error":"interrupted","is_interrupt":true}' | node hooks/hive-recall-error.js; echo $?` exits 0 (interrupt filtered, no event written)
5. `echo '{"session_id":"s1","cwd":"/tmp","trigger":"auto"}' | node hooks/hive-recall-compact.js; echo $?` exits 0
6. `echo 'garbage' | node hooks/hive-recall-error.js; echo $?` exits 0 (fail-silent)
7. `echo 'garbage' | node hooks/hive-recall-compact.js; echo $?` exits 0 (fail-silent)
  </verify>
  <done>
hive-recall-error.js captures tool_error events with tool name, command (for Bash), and error message. Skips interrupts. Filters for Hive projects only. hive-recall-compact.js captures context_compaction events with trigger type. Both fail silently on any error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session boundary hook observer (start + end)</name>
  <files>hooks/hive-recall-session.js</files>
  <action>
**Create hooks/hive-recall-session.js (SessionStart + SessionEnd observer):**

This is a SINGLE script handling BOTH SessionStart and SessionEnd via a CLI argument. The hook registration in settings.json (created by Plan 01) passes `start` or `end` as the argument:
- SessionStart: `node .claude/hooks/hive-recall-session.js start`
- SessionEnd: `node .claude/hooks/hive-recall-session.js end`

Follow the same pattern as the other hooks:

1. Shebang + header: `// Hive Recall -- Session boundary observer` and `// Hook: SessionStart + SessionEnd | Fail-silent`
2. Read mode from CLI: `const mode = process.argv[2];` (will be 'start' or 'end')
3. stdin parsing, try/catch (HOOK-06), HOOK-07 (.planning/ check), config check -- same pattern
4. Build event data based on mode:

**For mode === 'start':**
```
eventData = {
  action: 'start',
  session_type: data.source || 'unknown',  // startup/resume/clear/compact
  model: data.model || null
}
```
The `data.source` field maps to HOOK-04's "session type: startup/resume/clear/compact".

**For mode === 'end':**
```
eventData = {
  action: 'end',
  reason: data.reason || 'unknown',  // clear/logout/prompt_input_exit/etc.
  events_count: <counted>,
  agents_spawned: <counted>
}
```

For `events_count` and `agents_spawned` (HOOK-05): read events.jsonl, parse each line, filter by `e.session === data.session_id`, count total events and count events where `e.type === 'agent_completion'`. Wrap this counting in its OWN try/catch -- if the file doesn't exist or parsing fails, default both to 0. This counting reads a file that is at most 500KB (rotation threshold), so it takes <5ms.

5. Build event envelope:
```
{
  ts: new Date().toISOString(),
  session: data.session_id || 'unknown',
  type: 'session_boundary',
  v: 1,
  data: eventData
}
```
6. mkdirSync + appendFileSync

If mode is neither 'start' nor 'end', return early (defensive coding).
  </action>
  <verify>
1. `node -c hooks/hive-recall-session.js` passes syntax check
2. `echo '{"session_id":"s1","cwd":"/tmp","source":"startup","model":"claude-opus-4-6"}' | node hooks/hive-recall-session.js start; echo $?` exits 0
3. `echo '{"session_id":"s1","cwd":"/tmp","reason":"clear"}' | node hooks/hive-recall-session.js end; echo $?` exits 0
4. `echo 'garbage' | node hooks/hive-recall-session.js start; echo $?` exits 0 (fail-silent)
5. `echo '{}' | node hooks/hive-recall-session.js; echo $?` exits 0 (no mode arg = early return)
  </verify>
  <done>
hive-recall-session.js handles both SessionStart and SessionEnd via CLI argument. Start events record session_type and model. End events record reason, events_count, and agents_spawned (counted from events.jsonl for the current session). Filters for Hive projects only. Fails silently on any error.
  </done>
</task>

</tasks>

<verification>
1. All 3 new hook files pass `node -c` syntax check
2. All 3 fail silently on malformed input (`echo 'bad' | node hooks/hive-recall-*.js; echo $?` all exit 0)
3. All 3 check for .planning/ directory (HOOK-07 project-level filtering)
4. hive-recall-error.js skips `is_interrupt: true` events
5. hive-recall-session.js distinguishes start vs end via process.argv[2]
6. hive-recall-session.js end mode counts session events from events.jsonl
7. Together with Plan 01's hive-recall-agent.js, all 4 hook files exist covering all 5 Claude Code lifecycle events
</verification>

<success_criteria>
- hooks/hive-recall-error.js captures tool_error events for non-interrupt tool failures in Hive projects
- hooks/hive-recall-compact.js captures context_compaction events with trigger type in Hive projects
- hooks/hive-recall-session.js captures session_boundary events for both start and end, with session counting on end
- All 3 hooks are fail-silent (HOOK-06) and filter for Hive projects (HOOK-07)
- All hooks write events directly to events.jsonl using appendFileSync (no CLI overhead)
</success_criteria>

<output>
After completion, create `.planning/phases/02-hook-observers/02-02-SUMMARY.md`
</output>
