---
phase: 04-feedback-loop
plan: "02"
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - hive/workflows/execute-phase.md
  - hive/workflows/plan-phase.md
  - hive/workflows/quick.md
  - hive/workflows/new-project.md
  - hive/workflows/new-milestone.md
  - hive/workflows/research-phase.md
  - hive/workflows/verify-work.md
  - hive/workflows/diagnose-issues.md
  - hive/workflows/map-codebase.md
  - hive/workflows/audit-milestone.md
  - .claude/hive/workflows/execute-phase.md
  - .claude/hive/workflows/plan-phase.md
  - .claude/hive/workflows/quick.md
  - .claude/hive/workflows/new-project.md
  - .claude/hive/workflows/new-milestone.md
  - .claude/hive/workflows/research-phase.md
  - .claude/hive/workflows/verify-work.md
  - .claude/hive/workflows/diagnose-issues.md
  - .claude/hive/workflows/map-codebase.md
  - .claude/hive/workflows/audit-milestone.md
autonomous: true

must_haves:
  truths:
    - "Workflows that spawn agents pass a <recall> block with relevant past patterns to agent prompts when recall_context is available"
    - "The recall block is omitted when recall_context is null or empty (no noise in prompts)"
    - "Source workflow files (hive/) and installed copies (.claude/hive/) are synchronized"
  artifacts:
    - path: "hive/workflows/execute-phase.md"
      provides: "Recall block injection in executor Task() prompts"
      contains: "<recall>"
    - path: "hive/workflows/plan-phase.md"
      provides: "Recall block injection in researcher/planner/checker Task() prompts"
      contains: "<recall>"
    - path: "hive/workflows/quick.md"
      provides: "Recall block injection in quick planner/executor prompts"
      contains: "<recall>"
  key_links:
    - from: "execute-phase.md Task() prompt"
      to: "init execute-phase recall_context"
      via: "RECALL variable extraction from INIT JSON"
      pattern: "recall_context"
    - from: "plan-phase.md Task() prompt"
      to: "init plan-phase recall_context"
      via: "RECALL variable extraction from INIT JSON"
      pattern: "recall_context"
---

<objective>
Inject <recall> blocks into all workflow files that spawn agents via Task(), so every agent receives relevant past patterns from telemetry at spawn time.

Purpose: This closes the feedback loop -- agents spawned by workflows automatically receive project-specific patterns, enabling them to avoid known issues and follow proven approaches without explicit human instruction.
Output: 10 workflow files updated (source + installed copies = 20 file writes) with conditional recall block injection.
</objective>

<execution_context>
@./.claude/hive/workflows/execute-plan.md
@./.claude/hive/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-feedback-loop/04-RESEARCH.md
@.planning/phases/04-feedback-loop/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recall block to core execution workflows (execute-phase, plan-phase, quick)</name>
  <files>
hive/workflows/execute-phase.md
hive/workflows/plan-phase.md
hive/workflows/quick.md
.claude/hive/workflows/execute-phase.md
.claude/hive/workflows/plan-phase.md
.claude/hive/workflows/quick.md
  </files>
  <action>
For each of the three core workflows, add recall block injection following this pattern:

**Step 1: Extract RECALL from INIT JSON.**

Each workflow already runs an init command and parses the JSON. After the existing variable extractions, add:
```
RECALL=$(echo "$INIT" | jq -r '.recall_context // empty')
```
OR, if the workflow uses a different parsing approach (some use node -e), follow the same pattern used for other fields in that workflow.

**Step 2: Add conditional recall block to Task() prompts.**

In every Task() spawn within each workflow, add the following block. Place it AFTER `</files_to_read>` (or after the last context section) and BEFORE `<success_criteria>`:

```markdown
{If RECALL is non-empty, include this block in the Task() prompt:}

<recall>
Past project patterns from telemetry:
{RECALL}
Use these patterns to avoid known issues and follow proven approaches.
</recall>
```

**Specific insertion points:**

1. **execute-phase.md**:
   - Standalone mode: Inside the Task() prompt for executor agents (~line 427-457). Insert the recall block after `</files_to_read>` (line ~448) and before `<success_criteria>` (line ~450).
   - Team mode: Inside the planner/executor agent creation if there is a Task() prompt there too. Check both modes.
   - Note: source file uses `~/.claude/` paths, installed copy uses `./.claude/` paths -- preserve this convention.

2. **plan-phase.md**:
   - Researcher Task() prompt: Insert recall block after the researcher's context/files section.
   - Planner Task() prompt: Insert recall block after the planner's context/files section.
   - Checker Task() prompt: Insert recall block after the checker's context/files section.
   - All modes (standalone + team): Check every Task() spawn.

3. **quick.md**:
   - Planner Task() prompt: Insert recall block.
   - Executor Task() prompt: Insert recall block.

**Step 3: Copy source to installed location.**

After modifying each source file (`hive/workflows/X.md`), copy it to the installed location (`.claude/hive/workflows/X.md`). The installed copy should be IDENTICAL to the source EXCEPT for path references:
- Source uses `~/.claude/hive/` paths
- Installed uses `./.claude/hive/` paths
If the files already use the correct path convention, just copy. If they differ, ensure the installed copy uses `./.claude/` paths.
  </action>
  <verify>
1. Grep for recall block in all three source files: `grep -l "recall" hive/workflows/execute-phase.md hive/workflows/plan-phase.md hive/workflows/quick.md` should list all three
2. Grep for recall block in installed copies: `grep -l "recall" .claude/hive/workflows/execute-phase.md .claude/hive/workflows/plan-phase.md .claude/hive/workflows/quick.md` should list all three
3. Verify the recall block is conditional (not always present): grep for "non-empty" or "RECALL" conditional logic
4. Count Task() prompts in each file and confirm each one has a recall injection point
  </verify>
  <done>execute-phase.md, plan-phase.md, and quick.md all contain conditional recall block injection in every Task() prompt. Source and installed copies are synchronized.</done>
</task>

<task type="auto">
  <name>Task 2: Add recall block to remaining 7 agent-spawning workflows</name>
  <files>
hive/workflows/new-project.md
hive/workflows/new-milestone.md
hive/workflows/research-phase.md
hive/workflows/verify-work.md
hive/workflows/diagnose-issues.md
hive/workflows/map-codebase.md
hive/workflows/audit-milestone.md
.claude/hive/workflows/new-project.md
.claude/hive/workflows/new-milestone.md
.claude/hive/workflows/research-phase.md
.claude/hive/workflows/verify-work.md
.claude/hive/workflows/diagnose-issues.md
.claude/hive/workflows/map-codebase.md
.claude/hive/workflows/audit-milestone.md
  </files>
  <action>
Apply the same recall injection pattern from Task 1 to the remaining 7 workflows that spawn agents:

**For each workflow:**

1. **Find the init command call** and add RECALL extraction from the JSON output.
2. **Find every Task() prompt** in the workflow and add the conditional recall block after the context/files section and before success criteria.
3. **Copy source to installed location** (`.claude/hive/workflows/` mirror), maintaining the path convention (source uses `~/.claude/`, installed uses `./.claude/`).

**Workflow-specific notes:**

- **new-project.md**: Spawns researcher and synthesizer agents. Add recall to both Task() prompts.
- **new-milestone.md**: Spawns researcher. Add recall to researcher Task() prompt.
- **research-phase.md**: Spawns researcher. Add recall to researcher Task() prompt.
- **verify-work.md**: Spawns verifier and potentially gap-closure planner. Add recall to all Task() prompts.
- **diagnose-issues.md**: Spawns debugger agent. Add recall to debugger Task() prompt.
- **map-codebase.md**: Spawns mapper agent(s). Add recall to mapper Task() prompt(s).
- **audit-milestone.md**: Spawns checker agent. Add recall to checker Task() prompt.

**Important:** Some of these workflows may not have explicit INIT JSON parsing (they might use the init command differently). In those cases, add the recall extraction step:
```bash
RECALL=$(node ./.claude/hive/bin/hive-tools.js init {command} {args} --raw | node -e "const d=require('fs').readFileSync('/dev/stdin','utf8');const j=JSON.parse(d);process.stdout.write(j.recall_context||'')")
```
Or use the same pattern the workflow already uses for its init call.

**If a workflow does NOT spawn agents via Task()** (just runs inline logic), skip the recall injection for that workflow -- but based on research all 7 listed workflows DO spawn agents.
  </action>
  <verify>
1. Grep all 7 source files for recall: `grep -l "recall" hive/workflows/new-project.md hive/workflows/new-milestone.md hive/workflows/research-phase.md hive/workflows/verify-work.md hive/workflows/diagnose-issues.md hive/workflows/map-codebase.md hive/workflows/audit-milestone.md` should list all 7
2. Grep all 7 installed copies: `grep -l "recall" .claude/hive/workflows/new-project.md .claude/hive/workflows/new-milestone.md .claude/hive/workflows/research-phase.md .claude/hive/workflows/verify-work.md .claude/hive/workflows/diagnose-issues.md .claude/hive/workflows/map-codebase.md .claude/hive/workflows/audit-milestone.md` should list all 7
3. Diff source vs installed for one sample: `diff hive/workflows/verify-work.md .claude/hive/workflows/verify-work.md` should show only path differences (if any)
  </verify>
  <done>All 7 remaining agent-spawning workflows contain conditional recall block injection. Source and installed copies are synchronized. Total: 10 workflows updated across the phase.</done>
</task>

</tasks>

<verification>
1. All 10 source workflow files contain `<recall>` block: `grep -rl "recall" hive/workflows/execute-phase.md hive/workflows/plan-phase.md hive/workflows/quick.md hive/workflows/new-project.md hive/workflows/new-milestone.md hive/workflows/research-phase.md hive/workflows/verify-work.md hive/workflows/diagnose-issues.md hive/workflows/map-codebase.md hive/workflows/audit-milestone.md`
2. All 10 installed workflow copies contain `<recall>` block
3. Recall injection is conditional on non-empty RECALL variable
4. No workflow files are broken (markdown structure preserved, no unclosed tags)
</verification>

<success_criteria>
- 10 workflow files have conditional `<recall>` block injection in all Task() prompts
- Source files (hive/) and installed copies (.claude/hive/) are synchronized
- Recall block is only included when recall_context is non-empty
- Recall block placement: after context/files, before success criteria
- No existing workflow functionality broken
</success_criteria>

<output>
After completion, create `.planning/phases/04-feedback-loop/04-02-SUMMARY.md`
</output>
