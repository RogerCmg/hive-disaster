---
phase: 11-repo-manager
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - .claude/agents/hive-repo-manager.md
  - .claude/commands/hive/manage-repo.md
  - .claude/hive/workflows/manage-repo.md
autonomous: true

must_haves:
  truths:
    - "Running `/hive:manage-repo` launches the repo manager agent that reads the merge queue and processes pending merges"
    - "The repo manager processes entries in wave-aware order — all Wave 1 entries before any Wave 2 entry"
    - "Conflicting entries are flagged and skipped, not attempted — remaining entries in the wave still proceed"
    - "After processing a wave with failures, the repo manager stops and reports blockers instead of proceeding to the next wave"
    - "After each successful merge, the repo manager writes merge result and dev-head signal files"
  artifacts:
    - path: ".claude/agents/hive-repo-manager.md"
      provides: "Repo manager agent definition"
      contains: "hive-repo-manager"
    - path: ".claude/commands/hive/manage-repo.md"
      provides: "Thin command dispatcher"
      contains: "hive:manage-repo"
    - path: ".claude/hive/workflows/manage-repo.md"
      provides: "Repo manager workflow with queue processing loop"
      contains: "process_queue"
  key_links:
    - from: ".claude/commands/hive/manage-repo.md"
      to: ".claude/hive/workflows/manage-repo.md"
      via: "@-reference"
      pattern: "manage-repo\\.md"
    - from: ".claude/hive/workflows/manage-repo.md"
      to: "hive-tools.js git queue-status"
      via: "CLI invocation in workflow steps"
      pattern: "queue-status"
    - from: ".claude/hive/workflows/manage-repo.md"
      to: "hive-tools.js git run-gate-2"
      via: "CLI invocation for pre-merge build validation"
      pattern: "run-gate-2"
---

<objective>
Create the repo manager agent, command, and workflow that reads the merge queue and processes pending merges with wave-aware ordering, conflict detection, Gate 2 build validation, and file-based signaling.

Purpose: This is the intelligent merge orchestrator. While Plan 1 provides the tooling primitives, this plan provides the agent that composes them into a safe, wave-aware merge workflow. The repo manager prevents broken merges from reaching dev.

Output: `hive-repo-manager.md` agent definition, `manage-repo.md` command, `manage-repo.md` workflow.
</objective>

<execution_context>
@./.claude/hive/workflows/execute-plan.md
@./.claude/hive/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-repo-manager/11-RESEARCH.md
@.planning/phases/11-repo-manager/11-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create repo manager agent definition and command dispatcher</name>
  <files>.claude/agents/hive-repo-manager.md, .claude/commands/hive/manage-repo.md</files>
  <action>
**1. Create `.claude/agents/hive-repo-manager.md`:**

Follow the existing agent pattern (see hive-executor.md frontmatter for structure):

```yaml
---
name: hive-repo-manager
description: Processes the merge queue with wave-aware ordering, conflict detection, Gate 2 build validation, and file-based signaling. Ensures parallel plan merges never break dev.
tools: Read, Write, Bash, Grep, Glob
color: red
---
```

Agent body:

```markdown
<role>
You are a Hive repo manager. You process the merge queue, validate merges via conflict detection and Gate 2 pre-merge build validation, and ensure clean integration to dev.

Your job: Read `.hive-workers/merge-queue.json`, process pending entries in wave-aware order (Wave 1 before Wave 2), run conflict checks and Gate 2 builds, merge clean entries, flag problematic ones, and write signal files for communication.
</role>

<process>

<step name="init">
Load repo manager context:

```bash
QUEUE_STATUS=$(node ./.claude/hive/bin/hive-tools.js git queue-status --raw)
PENDING=$(echo "$QUEUE_STATUS" | jq -r '.pending_count')
DEV_HEAD=$(echo "$QUEUE_STATUS" | jq -r '.dev_head // "unknown"')
```

Read config for git flow settings:
```bash
GIT_FLOW=$(node ./.claude/hive/bin/hive-tools.js init execute-phase 11 --include config | jq -r '.config_content' | jq -r '.git.flow // "github"')
DEV_BRANCH=$(node ./.claude/hive/bin/hive-tools.js init execute-phase 11 --include config | jq -r '.config_content' | jq -r '.git.dev_branch // "dev"')
```

If PENDING is 0: report "Queue empty. Nothing to merge." and exit.
If GIT_FLOW is "none": report "Git flow disabled. Repo manager not needed." and exit.
</step>

<step name="verify_branch">
Ensure we are on the dev branch before any merge operations:

```bash
git checkout "${DEV_BRANCH}"
CURRENT=$(git branch --show-current)
```

If CURRENT is not DEV_BRANCH: abort with error "Cannot checkout dev branch. Aborting."

Clean any leftover merge state (crash recovery):
```bash
git merge --abort 2>/dev/null || true
```
</step>

<step name="process_queue">
Process merge queue in wave-aware order.

1. Get pending entries grouped by wave:
```bash
QUEUE_STATUS=$(node ./.claude/hive/bin/hive-tools.js git queue-status --raw)
PENDING_JSON=$(echo "$QUEUE_STATUS" | jq -c '[.pending[]]')
```

2. Extract unique waves sorted ascending:
```bash
WAVES=$(echo "$PENDING_JSON" | jq -r '[.[].wave] | unique | sort_by(.) | .[]')
```

3. For each wave (ascending order):

   a. Get entries for this wave:
   ```bash
   WAVE_ENTRIES=$(echo "$PENDING_JSON" | jq -c "[.[] | select(.wave == ${WAVE})]")
   ENTRY_COUNT=$(echo "$WAVE_ENTRIES" | jq -r 'length')
   ```

   b. Track wave results: `WAVE_MERGED=0`, `WAVE_FAILED=0`, `WAVE_SKIPPED=0`

   c. For each entry in the wave:

   **Step c.1 — Update status to 'checking':**
   ```bash
   node ./.claude/hive/bin/hive-tools.js git queue-update --id "${ENTRY_ID}" --status checking --raw
   ```

   **Step c.2 — Conflict check:**
   ```bash
   CONFLICTS=$(node ./.claude/hive/bin/hive-tools.js git check-conflicts --branch "${BRANCH}" --raw)
   HAS_CONFLICTS=$(echo "$CONFLICTS" | jq -r '.has_conflicts')
   ```

   If `has_conflicts` is true:
   - Update status: `queue-update --id "${ENTRY_ID}" --status conflict --error "Conflicts detected with current dev"`
   - Report: "CONFLICT: ${PLAN_ID} (${BRANCH}) has conflicts with dev. Skipping."
   - Increment WAVE_FAILED
   - Skip to next entry

   **Step c.3 — Update status to 'building', run Gate 2:**
   ```bash
   node ./.claude/hive/bin/hive-tools.js git queue-update --id "${ENTRY_ID}" --status building --raw
   GATE2=$(node ./.claude/hive/bin/hive-tools.js git run-gate-2 --branch "${BRANCH}" --raw)
   GATE2_SUCCESS=$(echo "$GATE2" | jq -r '.success')
   GATE2_SKIPPED=$(echo "$GATE2" | jq -r '.skipped // false')
   ```

   If Gate 2 skipped (no build command or gate disabled): proceed to merge.

   If Gate 2 failed (`success` false):
   - Update status: `queue-update --id "${ENTRY_ID}" --status build_failed --error "Gate 2 build failed"`
   - Report build failure details (command, exit code, stderr excerpt)
   - Present to user: "Gate 2 failed for ${PLAN_ID}. Options: fix / skip / stop"
     - fix: Investigate, apply fix to plan branch, retry Gate 2
     - skip: Leave as build_failed, continue to next entry
     - stop: Halt all processing, report partial results
   - Increment WAVE_FAILED (unless fix succeeds)
   - Skip to next entry (unless fix succeeds)

   **Step c.4 — Update status to 'merging', merge PR:**
   ```bash
   node ./.claude/hive/bin/hive-tools.js git queue-update --id "${ENTRY_ID}" --status merging --raw
   ```

   If PR number exists:
   ```bash
   MERGE=$(node ./.claude/hive/bin/hive-tools.js git self-merge-pr "${PR_NUMBER}" --raw)
   MERGE_SUCCESS=$(echo "$MERGE" | jq -r '.success')
   MERGE_SHA=$(git rev-parse --short HEAD)
   ```

   If merge succeeded:
   - Update queue: `queue-update --id "${ENTRY_ID}" --status merged --merge-sha "${MERGE_SHA}"`
   - Log: "MERGED: ${PLAN_ID} -> dev (PR #${PR_NUMBER}, SHA ${MERGE_SHA})"
   - Increment WAVE_MERGED
   - Ensure on dev: `git checkout "${DEV_BRANCH}" && git pull origin "${DEV_BRANCH}" 2>/dev/null || true`

   If merge failed:
   - Update: `queue-update --id "${ENTRY_ID}" --status merge_failed --error "${error}"`
   - Report to user
   - Increment WAVE_FAILED

   d. After all entries in wave processed:

   Report wave summary:
   ```
   Wave ${WAVE} complete: ${WAVE_MERGED} merged, ${WAVE_FAILED} failed, ${WAVE_SKIPPED} skipped
   ```

   **Critical wave gate:** If WAVE_FAILED > 0:
   - DO NOT proceed to next wave
   - Report: "Wave ${WAVE} has ${WAVE_FAILED} failed entries. Cannot proceed to Wave ${NEXT_WAVE}."
   - List failed entries with their status and error
   - Present options: "resolve (fix failed entries) / force (proceed despite failures) / stop"
   - If stop: exit processing
   - If force: proceed to next wave (warn about potential dependency issues)
   - If resolve: wait for user to fix, re-check failed entries

4. After all waves processed: proceed to summary step.
</step>

<step name="summary">
Report final merge queue state:

```bash
FINAL_STATUS=$(node ./.claude/hive/bin/hive-tools.js git queue-status --raw)
```

Display:
```
## Repo Manager Summary

**Processed:** ${TOTAL_PROCESSED} entries
**Merged:** ${TOTAL_MERGED}
**Failed:** ${TOTAL_FAILED}
**Dev HEAD:** ${DEV_HEAD}

{If all merged: "All entries merged successfully. Dev branch is clean."}
{If failures: list each failure with status and recommended action}
```

If all entries for the current phase/milestone are merged and this is the last phase:
- Suggest: "All plans merged. Consider running `/hive:complete-milestone` for dev-to-main merge."
</step>

</process>

<rules>
1. NEVER merge a Wave N+1 entry while Wave N has pending or failed entries (unless user explicitly forces)
2. ALWAYS verify on dev branch before each merge cycle
3. ALWAYS clean leftover merge state at startup (git merge --abort)
4. NEVER leave a git merge --no-commit state (Gate 2 handles this internally)
5. Report ALL results to the user — no silent failures
6. Conflicting entries are flagged and skipped, not retried automatically
7. Build failures get user options (fix/skip/stop), not automatic skip
</rules>
```

**2. Create `.claude/commands/hive/manage-repo.md`:**

Follow existing command pattern (thin dispatcher):

```yaml
---
name: hive:manage-repo
description: Launch the repo manager to process the merge queue with conflict detection and build validation
allowed-tools:
  - Read
  - Write
  - Edit
  - Glob
  - Grep
  - Bash
  - Task
  - AskUserQuestion
---
```

Body: Reference the workflow:
```markdown
Process the merge queue using the repo manager workflow.

@./.claude/hive/workflows/manage-repo.md

Follow the workflow instructions. The repo manager reads `.hive-workers/merge-queue.json` and processes pending merges in wave-aware order with conflict detection and Gate 2 build validation.
```
  </action>
  <verify>
Verify files exist: `ls -la .claude/agents/hive-repo-manager.md .claude/commands/hive/manage-repo.md`. Verify agent frontmatter has correct name field: `head -6 .claude/agents/hive-repo-manager.md`. Verify command has correct allowed-tools: `head -12 .claude/commands/hive/manage-repo.md`.
  </verify>
  <done>Agent definition exists with role, process steps (init, verify_branch, process_queue, summary), and rules. Command dispatcher exists with correct frontmatter and workflow reference.</done>
</task>

<task type="auto">
  <name>Task 2: Create repo manager workflow and sync source copies</name>
  <files>.claude/hive/workflows/manage-repo.md, hive/workflows/manage-repo.md</files>
  <action>
**1. Create `hive/workflows/manage-repo.md`** (source copy, uses `~/.claude/` paths):

The workflow orchestrates the repo manager. It loads context, reads the queue, and delegates to the agent for processing. Structure:

```markdown
<purpose>
Process the merge queue with wave-aware ordering, conflict detection, Gate 2 pre-merge build validation, and file-based signaling. Ensures parallel plan merges never break dev.
</purpose>

<required_reading>
@~/.claude/hive/references/git-integration.md
</required_reading>

<process>

<step name="init_context" priority="first">
Load repo manager context:

```bash
QUEUE_STATUS=$(node ~/.claude/hive/bin/hive-tools.js git queue-status --raw)
PENDING=$(echo "$QUEUE_STATUS" | jq -r '.pending_count')
FAILED=$(echo "$QUEUE_STATUS" | jq -r '.failed_count')
```

If PENDING is 0 and FAILED is 0:
- Report: "Merge queue is empty. Nothing to process."
- Suggest: "Submit plans to the queue via execute-phase with repo_manager enabled, or manually via `hive-tools.js git queue-submit`."
- Exit.

If PENDING is 0 but FAILED > 0:
- Report: "No pending entries, but ${FAILED} failed entries remain."
- Show failed entries from QUEUE_STATUS
- Suggest resolution options
- Exit unless user wants to retry.
</step>

<step name="verify_environment">
Verify git environment is ready:

```bash
GIT_DETECT=$(node ~/.claude/hive/bin/hive-tools.js git detect --raw)
GIT_VERSION=$(echo "$GIT_DETECT" | jq -r '.git.version')
MERGE_TREE=$(echo "$GIT_DETECT" | jq -r '.git.merge_tree_available')
```

Report: "Git ${GIT_VERSION}, merge-tree: ${MERGE_TREE}"

Check current branch and ensure on dev:
```bash
CURRENT_BRANCH=$(node ~/.claude/hive/bin/hive-tools.js git current-branch --raw | jq -r '.branch')
DEV_BRANCH=$(cat .planning/config.json 2>/dev/null | jq -r '.git.dev_branch // "dev"')
```

If not on dev: `git checkout "${DEV_BRANCH}"`.
Clean leftover merge state: `git merge --abort 2>/dev/null || true`.
</step>

<step name="process_waves">
Read queue and process by wave.

```bash
QUEUE_STATUS=$(node ~/.claude/hive/bin/hive-tools.js git queue-status --raw)
PENDING_ENTRIES=$(echo "$QUEUE_STATUS" | jq -c '.pending')
```

Extract unique waves:
```bash
WAVES=$(echo "$PENDING_ENTRIES" | jq -r '[.[].wave] | unique | sort_by(.) | .[]')
```

For each wave (lowest first):

1. Log: "Processing Wave ${WAVE} (${ENTRY_COUNT} entries)"

2. For each entry in wave:
   a. **Conflict check:** `node ~/.claude/hive/bin/hive-tools.js git check-conflicts --branch "${BRANCH}" --raw`
      - Clean -> proceed
      - Conflict -> `queue-update --status conflict`, skip entry

   b. **Gate 2 build:** `node ~/.claude/hive/bin/hive-tools.js git run-gate-2 --branch "${BRANCH}" --raw`
      - Pass/skip -> proceed
      - Fail -> `queue-update --status build_failed`, present fix/skip/stop options

   c. **Merge PR:** `node ~/.claude/hive/bin/hive-tools.js git self-merge-pr "${PR_NUMBER}" --raw`
      - Success -> `queue-update --status merged --merge-sha ${SHA}`, checkout dev, pull
      - Fail -> `queue-update --status merge_failed`, report

3. After wave: check for failures. If any failed: STOP, report, wait for resolution or force.
</step>

<step name="report_results">
After all processing:

```bash
FINAL=$(node ~/.claude/hive/bin/hive-tools.js git queue-status --raw)
```

Display summary: total processed, merged count, failed count, dev HEAD.

If all merged: suggest next steps (complete-milestone if last phase).
If failures remain: list them with recommended actions.
</step>

</process>

<success_criteria>
- All pending queue entries processed in wave-aware order
- Conflicts detected before merge attempt
- Gate 2 validates integration before merge
- Failed entries flagged with clear error information
- Dev branch updated after each successful merge
- Wave ordering preserved (Wave N must complete before Wave N+1)
</success_criteria>
```

**2. Sync to installed location.** Copy `hive/workflows/manage-repo.md` to `.claude/hive/workflows/manage-repo.md` with path substitution:
```bash
sed 's|~/\\.claude/|./.claude/|g' hive/workflows/manage-repo.md > .claude/hive/workflows/manage-repo.md
```

**3. Also sync the agent to the hive source directory** if one exists (check pattern):
- The `.claude/agents/` is the installed location
- Check if `hive/agents/` exists as source. If not, the installed location IS the source for agents (agents are only in `.claude/agents/`).
- Do NOT create `hive/agents/` if it doesn't exist. Agents live only in `.claude/agents/`.
  </action>
  <verify>
Verify workflow exists: `ls -la hive/workflows/manage-repo.md .claude/hive/workflows/manage-repo.md`. Verify installed copy uses relative paths: `grep '~/.claude/' .claude/hive/workflows/manage-repo.md` should return nothing (all converted to `./.claude/`). Verify source copy uses home paths: `grep '~/.claude/' hive/workflows/manage-repo.md` should return matches.
  </verify>
  <done>Workflow file exists in both source (hive/) and installed (.claude/hive/) locations with correct path conventions. Workflow has init_context, verify_environment, process_waves, and report_results steps. Wave-aware processing enforces dependency ordering.</done>
</task>

</tasks>

<verification>
1. `.claude/agents/hive-repo-manager.md` exists with correct frontmatter (name, tools, color)
2. `.claude/commands/hive/manage-repo.md` exists with workflow reference
3. `hive/workflows/manage-repo.md` uses `~/` paths
4. `.claude/hive/workflows/manage-repo.md` uses `./` paths
5. Workflow references queue-status, check-conflicts, run-gate-2, self-merge-pr, queue-update subcommands
6. Wave processing loop: groups by wave, sorts ascending, stops on failure
7. Agent has clear rules for wave ordering, branch verification, crash recovery
</verification>

<success_criteria>
The `/hive:manage-repo` command exists and references the manage-repo workflow. The workflow reads the merge queue, processes entries in wave-aware order, runs conflict detection and Gate 2 build validation before each merge, writes signal files, and stops at wave boundaries when failures occur. The agent definition includes all processing rules and error handling.
</success_criteria>

<output>
After completion, create `.planning/phases/11-repo-manager/11-02-SUMMARY.md`
</output>
