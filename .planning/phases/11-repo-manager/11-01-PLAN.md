---
phase: 11-repo-manager
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hive/bin/hive-tools.js
autonomous: true

must_haves:
  truths:
    - "Running `hive-tools.js git queue-submit` with plan_id, branch, wave, pr_number creates a pending entry in `.hive-workers/merge-queue.json`"
    - "Running `hive-tools.js git queue-status` returns pending count, failed count, merged count, and dev_head from the queue file"
    - "Running `hive-tools.js git queue-update` changes an entry's status and records error/merge details"
    - "Running `hive-tools.js git run-gate-2 --branch <name>` performs git merge --no-commit on dev, runs build, and always git merge --abort after"
    - "All queue operations use withFileLock to prevent concurrent corruption"
    - "Signal files are written atomically to `.hive-workers/signals/` after merge operations"
  artifacts:
    - path: "hive/bin/hive-tools.js"
      provides: "Queue subcommands and Gate 2 implementation"
      contains: "cmdGitQueueSubmit"
  key_links:
    - from: "hive/bin/hive-tools.js (queue-submit)"
      to: ".hive-workers/merge-queue.json"
      via: "withFileLock + atomicWriteFileSync"
      pattern: "withFileLock.*merge-queue"
    - from: "hive/bin/hive-tools.js (run-gate-2)"
      to: "git merge --no-commit"
      via: "execCommand with try/finally abort"
      pattern: "merge.*--no-commit"
    - from: "hive/bin/hive-tools.js (CLI router)"
      to: "queue-submit, queue-status, queue-update, queue-drain, run-gate-2"
      via: "git subcommand dispatch"
      pattern: "queue-submit|queue-status|queue-update|queue-drain|run-gate-2"
---

<objective>
Implement the merge queue data structure, CRUD subcommands, Gate 2 pre-merge build validation, and signal file helpers in hive-tools.js.

Purpose: Provide the tooling primitives that the repo manager agent (Plan 2) and execute-plan integration (Plan 3) will compose. This is the foundation layer -- queue operations, conflict-aware merge validation, and file-based signaling.

Output: 5 new git subcommands (queue-submit, queue-status, queue-update, queue-drain, run-gate-2), 2 signal helper functions, updated CLI router.
</objective>

<execution_context>
@./.claude/hive/workflows/execute-plan.md
@./.claude/hive/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-repo-manager/11-RESEARCH.md
@.planning/phases/08-safety-configuration/08-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add merge queue subcommands and signal helpers to hive-tools.js</name>
  <files>hive/bin/hive-tools.js</files>
  <action>
Add the following functions to hive-tools.js, placed after the existing git subcommand handlers (after `cmdGitDeletePlanBranch`) and before the CLI router:

**1. `writeMergeSignal(cwd, planId, status, details)`** — Helper function (not a CLI subcommand). Writes a signal file to `.hive-workers/signals/merge-{planId}.result.json`. Creates the signals directory if needed. Uses `atomicWriteFileSync`. Signal data: `{ plan_id, status, ...details, timestamp: new Date().toISOString() }`.

**2. `writeDevHeadSignal(cwd, sha, lastMerged)`** — Helper function. Writes `.hive-workers/signals/dev-head.json`. Uses `atomicWriteFileSync`. Data: `{ sha, updated_at: new Date().toISOString(), last_merged: lastMerged }`.

**3. `ensureGitignoreHiveWorkers(cwd)`** — Helper function. Checks if `.gitignore` contains `.hive-workers/`. If not, appends `\n# Hive worker state (runtime, not committed)\n.hive-workers/\n` to `.gitignore`. Called once by queue-submit on first invocation. Idempotent.

**4. `cmdGitQueueSubmit(cwd, options, raw)`** — CLI subcommand. Options parsed from CLI args: `--plan-id`, `--branch`, `--wave`, `--pr-number`, `--pr-url`. Validates plan_id and branch are provided. Reads or creates `.hive-workers/merge-queue.json` inside `withFileLock`. Generates ID: `'mr-' + String(queue.length + merged.length + 1).padStart(3, '0')`. Pushes entry with fields: id, plan_id, phase (extracted from plan_id split on '-'), plan (extracted), branch, wave (parseInt or default 1), status 'pending', submitted_at (ISO), pr_number (parseInt or null), pr_url (or null), checks: { conflicts: null, build: null }, error: null, merged_at: null. Updates last_updated. Writes with atomicWriteFileSync. Calls `ensureGitignoreHiveWorkers` on first use. Returns: `{ success: true, id, plan_id }`.

**5. `cmdGitQueueStatus(cwd, raw)`** — CLI subcommand. Reads merge-queue.json. If missing or corrupt, returns `{ success: true, empty: true, queue: [], merged: [], dev_head: null }`. Groups: pending (status 'pending'), in_progress (status in ['checking', 'building', 'merging']), failed (status in ['conflict', 'build_failed', 'merge_failed']). Returns: `{ success: true, pending_count, in_progress_count, failed_count, merged_count, dev_head, last_updated, pending, failed }`.

**6. `cmdGitQueueUpdate(cwd, options, raw)`** — CLI subcommand. Options: `--id`, `--status`, `--error`, `--merge-sha`, `--pr-number`, `--pr-url`. Uses `withFileLock`. Finds entry by id in queue array. Updates status and any provided fields. If new status is 'merged': set merged_at to ISO now, move entry from queue to merged array (with id, plan_id, branch, merged_at, merge_sha fields only), update dev_head to merge_sha if provided. Cap merged array at 50 entries (remove oldest). Update last_updated. Returns: `{ success: true, id, status: newStatus }`. If entry not found: `{ success: false, error: 'entry not found: ' + id }`.

**7. `cmdGitQueueDrain(cwd, raw)`** — CLI subcommand. Removes all entries from queue with terminal statuses ('merged', 'conflict', 'build_failed', 'merge_failed'). Cleans up signal files in `.hive-workers/signals/` for drained entries. Returns: `{ success: true, drained_count, remaining_count }`.

For all queue subcommands: check `config.git_flow`. If 'none', return `{ success: true, skipped: true, reason: 'git.flow is none' }`.

Ensure `.hive-workers/` directory is created with `fs.mkdirSync(dir, { recursive: true })` before any queue write.
  </action>
  <verify>
Run `node hive/bin/hive-tools.js git queue-status --raw` and confirm it returns valid JSON with `empty: true`. Run `node hive/bin/hive-tools.js git queue-submit --plan-id 11-01 --branch test-branch --wave 1 --raw` and confirm it returns `success: true` with an id. Run `node hive/bin/hive-tools.js git queue-status --raw` again and confirm `pending_count: 1`. Run `node hive/bin/hive-tools.js git queue-update --id mr-001 --status merged --merge-sha abc1234 --raw` and confirm success. Run `node hive/bin/hive-tools.js git queue-drain --raw` and confirm `drained_count: 1`.
  </verify>
  <done>All 4 queue subcommands (queue-submit, queue-status, queue-update, queue-drain) return structured JSON. Queue entries are created, updated, moved to merged, and drained correctly. Signal helpers write atomic files. withFileLock protects all writes. .hive-workers/ is gitignored.</done>
</task>

<task type="auto">
  <name>Task 2: Add Gate 2 pre-merge build subcommand and wire CLI router</name>
  <files>hive/bin/hive-tools.js</files>
  <action>
**1. Add `cmdGitRunGate2(cwd, branchName, raw)` function** after the queue subcommands:

- Check `config.git_flow`. If 'none': return skipped.
- Validate branchName is provided. If not: return `{ success: false, error: 'branch name required (--branch <name>)' }`.
- Check `config.git_build_gates_pre_merge` (loaded via loadConfig, field is `git_build_gates_pre_merge`). If false: return `{ success: true, skipped: true, reason: 'pre_merge gate disabled' }`.
- Get devBranch from `config.git_dev_branch || 'dev'`.
- Run `execCommand('git', ['checkout', devBranch], { cwd })`. If fail: return error.
- **Crash recovery:** Run `execCommand('git', ['merge', '--abort'], { cwd })` -- ignore result (cleans leftover merge state).
- Run `execCommand('git', ['merge', '--no-commit', '--no-ff', branchName], { cwd })`.
  - If fail: run `execCommand('git', ['merge', '--abort'], { cwd })`. Return `{ success: false, gate: 'pre_merge', error: 'merge_conflict', branch: branchName, stderr: mergeResult.stderr.slice(0, 2000) }`.
- Detect build command: `config.git_build_command || detectBuildCommand(cwd).command`.
  - If no build command: run `execCommand('git', ['merge', '--abort'], { cwd })`. Return `{ success: true, gate: 'pre_merge', skipped: true, reason: 'no build command' }`.
- Run build inside try/finally:
  - try: `const parts = buildCmd.split(/\s+/); buildResult = execCommand(parts[0], parts.slice(1), { cwd, timeout: timeoutMs });`
  - finally: `execCommand('git', ['merge', '--abort'], { cwd })` -- **ALWAYS abort, this is critical**.
- Return: `{ success: buildResult.success, gate: 'pre_merge', branch: branchName, command: buildCmd, exitCode: buildResult.exitCode, timedOut: buildResult.timedOut || false, stdout: buildResult.stdout.slice(0, 2000), stderr: buildResult.stderr.slice(0, 2000) }`.

**2. Update the git CLI router** (the `case 'git':` block, around line 5965):

Add these new subcommand routes BEFORE the `else` error handler:

```javascript
} else if (subcommand === 'queue-submit') {
  const planIdIdx = args.indexOf('--plan-id');
  const branchIdx = args.indexOf('--branch');
  const waveIdx = args.indexOf('--wave');
  const prNumIdx = args.indexOf('--pr-number');
  const prUrlIdx = args.indexOf('--pr-url');
  cmdGitQueueSubmit(cwd, {
    plan_id: planIdIdx !== -1 ? args[planIdIdx + 1] : null,
    branch: branchIdx !== -1 ? args[branchIdx + 1] : null,
    wave: waveIdx !== -1 ? args[waveIdx + 1] : null,
    pr_number: prNumIdx !== -1 ? args[prNumIdx + 1] : null,
    pr_url: prUrlIdx !== -1 ? args[prUrlIdx + 1] : null,
  }, raw);
} else if (subcommand === 'queue-status') {
  cmdGitQueueStatus(cwd, raw);
} else if (subcommand === 'queue-update') {
  const idIdx = args.indexOf('--id');
  const statusIdx = args.indexOf('--status');
  const errorIdx = args.indexOf('--error');
  const mergeShaIdx = args.indexOf('--merge-sha');
  const prNumIdx = args.indexOf('--pr-number');
  const prUrlIdx = args.indexOf('--pr-url');
  cmdGitQueueUpdate(cwd, {
    id: idIdx !== -1 ? args[idIdx + 1] : null,
    status: statusIdx !== -1 ? args[statusIdx + 1] : null,
    error: errorIdx !== -1 ? args[errorIdx + 1] : null,
    merge_sha: mergeShaIdx !== -1 ? args[mergeShaIdx + 1] : null,
    pr_number: prNumIdx !== -1 ? args[prNumIdx + 1] : null,
    pr_url: prUrlIdx !== -1 ? args[prUrlIdx + 1] : null,
  }, raw);
} else if (subcommand === 'queue-drain') {
  cmdGitQueueDrain(cwd, raw);
} else if (subcommand === 'run-gate-2') {
  const branchIdx = args.indexOf('--branch');
  const g2Branch = branchIdx !== -1 ? args[branchIdx + 1] : null;
  cmdGitRunGate2(cwd, g2Branch, raw);
}
```

Also update the error message's "Available:" list to include the new subcommands.

**3. Sync installed copy.** After editing `hive/bin/hive-tools.js`, sync to `.claude/hive/bin/hive-tools.js` using the standard path substitution:
```bash
sed 's|~/\\.claude/|./.claude/|g' hive/bin/hive-tools.js > .claude/hive/bin/hive-tools.js
```
  </action>
  <verify>
Run `node hive/bin/hive-tools.js git run-gate-2 --raw` (no --branch) and confirm it returns an error about branch required. Run `node hive/bin/hive-tools.js git queue-submit --plan-id test-99 --branch fake-branch --wave 1 --raw` and verify JSON output with success true. Check the error message includes the new subcommands by running `node hive/bin/hive-tools.js git unknown-cmd 2>&1` and verifying it lists queue-submit, queue-status, queue-update, queue-drain, run-gate-2. Clean up test data: `rm -rf .hive-workers/`.
  </verify>
  <done>Gate 2 subcommand implements git merge --no-commit + build + git merge --abort with try/finally safety. CLI router dispatches all 5 new subcommands. Installed copy is synced. Error message lists all available subcommands.</done>
</task>

</tasks>

<verification>
1. `node hive/bin/hive-tools.js git queue-status --raw` returns valid JSON
2. `node hive/bin/hive-tools.js git queue-submit --plan-id 11-01 --branch test --wave 1 --raw` creates entry
3. `node hive/bin/hive-tools.js git queue-update --id mr-001 --status conflict --raw` updates entry
4. `node hive/bin/hive-tools.js git queue-drain --raw` cleans terminal entries
5. `node hive/bin/hive-tools.js git run-gate-2 --branch nonexistent --raw` returns structured error (merge conflict or branch not found)
6. `.hive-workers/` directory created on first queue operation
7. All functions use withFileLock for writes and atomicWriteFileSync for signal files
</verification>

<success_criteria>
All 5 new git subcommands (queue-submit, queue-status, queue-update, queue-drain, run-gate-2) are implemented in hive-tools.js, wired in the CLI router, return structured JSON, and handle error cases gracefully. Gate 2 always runs git merge --abort in a finally block. Queue operations are protected by file locks. Signal helpers write atomic files. Installed copy is synced.
</success_criteria>

<output>
After completion, create `.planning/phases/11-repo-manager/11-01-SUMMARY.md`
</output>
