---
phase: 13-build-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hive/bin/hive-tools.js
  - .claude/hive/bin/hive-tools.js
  - hive/templates/config.json
  - .claude/hive/templates/config.json
autonomous: true

must_haves:
  truths:
    - "build_command configured as an array executes each command sequentially and stops on first failure"
    - "build_command configured as a string still works exactly as before (backward compatible)"
    - "When require_build is true and no build command is detected, the gate returns an error instead of skipping"
    - "When require_build is false or unset, missing build command still skips silently (backward compatible)"
  artifacts:
    - path: "hive/bin/hive-tools.js"
      provides: "Array pipeline execution in build gates, require_build enforcement"
      contains: "Array.isArray"
    - path: "hive/templates/config.json"
      provides: "require_build field in build_gates section"
      contains: "require_build"
  key_links:
    - from: "loadConfig"
      to: "cmdGitRunBuildGate"
      via: "git_build_command (string or array) and git_require_build"
      pattern: "config\\.git_build_command|config\\.git_require_build"
    - from: "loadConfig"
      to: "cmdGitRunGate2"
      via: "git_build_command (string or array) and git_require_build"
      pattern: "config\\.git_build_command|config\\.git_require_build"
---

<objective>
Support array build pipelines and require_build enforcement in all build gates.

Purpose: Real-world projects need multi-step build pipelines (lint, test, build) that run sequentially and stop on first failure. Projects that require builds should fail loudly when no command is detected, not silently skip.

Output: Modified hive-tools.js with array pipeline support in cmdGitRunBuildGate and cmdGitRunGate2, require_build config field, and updated config template.
</objective>

<execution_context>
@./.claude/hive/workflows/execute-plan.md
@./.claude/hive/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@hive/bin/hive-tools.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add array pipeline execution and require_build to hive-tools.js</name>
  <files>hive/bin/hive-tools.js, .claude/hive/bin/hive-tools.js</files>
  <action>
Three changes to hive-tools.js (apply identically to both copies):

**1. loadConfig — parse new fields:**

In the `loadConfig` function, add these new fields to the returned object:

- `git_build_command`: Already exists. No change needed — it already passes through whatever value is in config (string or array). The array handling happens in the gate functions.
- `git_require_build`: New field. Read from `buildGates.require_build`. Default: `false`. Add to defaults object as `git_require_build: false` and to the return object as `git_require_build: buildGates.require_build ?? defaults.git_require_build`.

**2. cmdGitRunBuildGate — support array pipeline + require_build:**

Current code resolves build command and runs it as a single string. Replace the build resolution and execution section:

After the `git.flow === 'none'` check, change the build command resolution:

```javascript
const buildCmd = config.git_build_command || detectBuildCommand(cwd).command;
if (!buildCmd) {
  // NEW: Check require_build flag
  if (config.git_require_build) {
    output({ success: false, error: 'require_build is true but no build command detected. Set git.build_command in config.json or add a test script to package.json.', required: true }, raw, 'fail');
    return;
  }
  output({ success: true, skipped: true, reason: 'no build command detected' }, raw, 'skipped');
  return;
}

const timeoutMs = (config.git_build_timeout || 300) * 1000;

// Support array of commands (pipeline) or single string
const commands = Array.isArray(buildCmd) ? buildCmd : [buildCmd];
let lastResult = null;

for (const cmd of commands) {
  const parts = cmd.split(/\s+/);
  lastResult = execCommand(parts[0], parts.slice(1), { cwd, timeout: timeoutMs });
  if (!lastResult.success) {
    output({
      success: false,
      command: cmd,
      pipeline: commands.length > 1 ? commands : undefined,
      failed_at: commands.indexOf(cmd) + 1,
      exitCode: lastResult.exitCode,
      timedOut: lastResult.timedOut || false,
      stdout: lastResult.stdout.slice(0, 2000),
      stderr: lastResult.stderr.slice(0, 2000),
    }, raw, 'fail');
    return;
  }
}

// All commands passed
output({
  success: true,
  command: commands.length === 1 ? commands[0] : commands.join(' && '),
  pipeline: commands.length > 1 ? commands : undefined,
  exitCode: 0,
  timedOut: false,
  stdout: (lastResult ? lastResult.stdout : '').slice(0, 2000),
  stderr: (lastResult ? lastResult.stderr : '').slice(0, 2000),
}, raw, 'pass');
```

Note: The `command` field in the output uses `&&`-joined string for backward compatibility with callers that display it. The `pipeline` field is only present for multi-command arrays.

**3. cmdGitRunGate2 — same array pipeline + require_build support:**

Apply the same changes to cmdGitRunGate2. The build resolution section (after the no-commit merge succeeds) currently does:

```javascript
const buildCmd = config.git_build_command || detectBuildCommand(cwd).command;
if (!buildCmd) {
  execCommand('git', ['merge', '--abort'], { cwd });
  output({ success: true, gate: 'pre_merge', skipped: true, reason: 'no build command' }, raw, 'skipped');
  return;
}
```

Change to:

```javascript
const buildCmd = config.git_build_command || detectBuildCommand(cwd).command;
if (!buildCmd) {
  execCommand('git', ['merge', '--abort'], { cwd });
  if (config.git_require_build) {
    output({ success: false, gate: 'pre_merge', error: 'require_build is true but no build command detected', required: true }, raw, 'fail');
    return;
  }
  output({ success: true, gate: 'pre_merge', skipped: true, reason: 'no build command' }, raw, 'skipped');
  return;
}
```

And change the build execution section from:

```javascript
const parts = buildCmd.split(/\s+/);
buildResult = execCommand(parts[0], parts.slice(1), { cwd, timeout: timeoutMs });
```

To:

```javascript
const commands = Array.isArray(buildCmd) ? buildCmd : [buildCmd];
for (const cmd of commands) {
  const parts = cmd.split(/\s+/);
  buildResult = execCommand(parts[0], parts.slice(1), { cwd, timeout: timeoutMs });
  if (!buildResult.success) break;
}
```

The output section remains the same (it already references `buildCmd` for the command field). Update the `command` field in the output to use the joined string: `command: commands.length === 1 ? commands[0] : commands.join(' && ')`.

**IMPORTANT:** Apply ALL changes identically to both `hive/bin/hive-tools.js` and `.claude/hive/bin/hive-tools.js`. Use `git add -f .claude/hive/bin/hive-tools.js` since it's gitignored but tracked.
  </action>
  <verify>
Verify the changes:

```bash
# Check loadConfig has new field
grep -n "git_require_build" hive/bin/hive-tools.js
grep -n "git_require_build" .claude/hive/bin/hive-tools.js

# Check array support exists
grep -n "Array.isArray" hive/bin/hive-tools.js | grep -i build

# Check both files are identical in the changed functions
diff <(grep -A5 "git_require_build" hive/bin/hive-tools.js) <(grep -A5 "git_require_build" .claude/hive/bin/hive-tools.js)

# Verify the tool still runs without errors
node hive/bin/hive-tools.js git detect-build-cmd --raw
```
  </verify>
  <done>
  - loadConfig returns git_require_build field (default false)
  - cmdGitRunBuildGate executes array of commands sequentially, stops on first failure, returns error on require_build with no command
  - cmdGitRunGate2 has matching array pipeline and require_build support
  - Both hive-tools.js copies are identical
  - Single string build_command still works unchanged (backward compatible)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update config template with require_build field</name>
  <files>hive/templates/config.json, .claude/hive/templates/config.json</files>
  <action>
Add the `require_build` field to the `build_gates` section in the config template.

In both `hive/templates/config.json` and `.claude/hive/templates/config.json`, update the git.build_gates section from:

```json
"build_gates": {
  "pre_pr": true,
  "pre_merge": true,
  "pre_main": true
}
```

To:

```json
"build_gates": {
  "pre_pr": true,
  "pre_merge": true,
  "pre_main": true,
  "require_build": false
}
```

Also update `build_command` from `null` to show the array example as a comment-like value. Since JSON doesn't support comments, keep it as `null` but the require_build field itself documents the intent. The `build_command` field already accepts both string and array — no template change needed there.

**Apply to both copies identically.**
  </action>
  <verify>
```bash
# Verify require_build exists in both templates
grep "require_build" hive/templates/config.json
grep "require_build" .claude/hive/templates/config.json

# Verify valid JSON
node -e "JSON.parse(require('fs').readFileSync('hive/templates/config.json','utf8')); console.log('valid')"
node -e "JSON.parse(require('fs').readFileSync('.claude/hive/templates/config.json','utf8')); console.log('valid')"
```
  </verify>
  <done>
  - Config template includes require_build: false in build_gates section
  - Both copies (hive/ and .claude/) are identical
  - JSON is valid
  </done>
</task>

</tasks>

<verification>
1. `grep -c "Array.isArray" hive/bin/hive-tools.js` returns at least 1 match in build gate context
2. `grep -c "git_require_build" hive/bin/hive-tools.js` returns at least 3 (default, parse, 2 usages)
3. `grep "require_build" hive/templates/config.json` shows the field
4. `node hive/bin/hive-tools.js git detect-build-cmd --raw` still works
5. Both hive-tools.js copies match in the modified functions
</verification>

<success_criteria>
- build_command as array ["npm run lint", "npm test"] would execute sequentially, stopping on first failure
- build_command as string "npm test" still works exactly as before
- require_build: true with no build command returns error (not skip)
- require_build: false (default) preserves current behavior
- Config template documents the new require_build field
</success_criteria>

<output>
After completion, create `.planning/phases/13-build-pipeline/13-01-SUMMARY.md`
</output>
