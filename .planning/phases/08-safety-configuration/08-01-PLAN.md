---
phase: 08-safety-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hive/bin/hive-tools.js
  - hive/templates/config.json
  - .claude/hive/bin/hive-tools.js
  - .claude/hive/templates/config.json
autonomous: true

must_haves:
  truths:
    - "acquireLock with mkdir creates a .lock directory atomically; second call throws EEXIST"
    - "atomicWriteFileSync writes to a temp file then renames — a crash mid-write leaves the old file intact"
    - "withFileLock acquires lock, runs callback, releases lock even if callback throws"
    - "loadConfig returns git_flow, git_dev_branch, git_build_gates_pre_pr, git_build_gates_pre_merge, git_build_gates_pre_main, git_build_command, git_build_timeout, git_merge_strategy with correct defaults when config has no git section"
    - "detectBuildCommand returns npm test for Node projects, cargo test for Rust, and {detected: false} for empty projects"
    - "detectBuildCommand returns {detected: false} when package.json has the npm default placeholder test script"
    - "execCommand wraps spawnSync and returns {success, exitCode, stdout, stderr, timedOut} without throwing on non-zero exit"
    - "cmdGitDetect returns git version, merge_tree availability, gh CLI availability as structured JSON"
    - "cmdGitDetectBuildCmd returns auto-detected build command or config override as structured JSON"
  artifacts:
    - path: "hive/bin/hive-tools.js"
      provides: "Safety primitives, execCommand, config extension, detection functions"
      contains: "acquireLock"
    - path: "hive/templates/config.json"
      provides: "Config template with git section"
      contains: "git"
  key_links:
    - from: "hive/bin/hive-tools.js (loadConfig)"
      to: "hive/templates/config.json"
      via: "git section defaults"
      pattern: "git_flow.*git_dev_branch.*git_build"
    - from: "hive/bin/hive-tools.js (atomicWriteFileSync)"
      to: "fs.writeFileSync + fs.renameSync"
      via: "same-directory temp+rename"
      pattern: "renameSync.*tmpPath"
    - from: "hive/bin/hive-tools.js (execCommand)"
      to: "child_process.spawnSync"
      via: "structured return wrapper"
      pattern: "spawnSync"
---

<objective>
Add crash-safe file operations, git config schema, and auto-detection primitives to hive-tools.js.

Purpose: Phase 8 foundation — safety primitives (SAFE-01, SAFE-02), config schema (SETUP-01), auto-detection (SETUP-02, SETUP-03), flow bypass (SETUP-04), and the spawnSync-based command runner (INTG-04 prerequisite). Plan 2 builds all git subcommands on top of these utilities.

Output: Extended hive-tools.js with safety primitives, config git section, detection functions, and two detection subcommands (`git detect`, `git detect-build-cmd`). Updated config.json template.
</objective>

<execution_context>
@./.claude/hive/workflows/execute-plan.md
@./.claude/hive/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-safety-configuration/08-RESEARCH.md
@hive/bin/hive-tools.js
@hive/templates/config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add safety primitives, execCommand, and config extension to hive-tools.js</name>
  <files>
    hive/bin/hive-tools.js
    hive/templates/config.json
  </files>
  <action>
  **1. Add `os` and `spawnSync` imports (line ~129):**

  Change the imports to include `os` and `spawnSync`:
  ```javascript
  const fs = require('fs');
  const path = require('path');
  const { execSync, spawnSync } = require('child_process');
  const os = require('os');
  ```

  **2. Add a new section after the existing `execGit` function (~line 258), using the established ASCII-art separator pattern:**

  ```
  // ─── File Safety Primitives ────────────────────────────────────────────────────
  ```

  Add these functions:

  **`acquireLock(filePath, options)`** — mkdir-based lock:
  - `options`: `{ retries: 50, retryDelay: 100, staleMs: 10000 }` (defaults)
  - Lock path: `filePath + '.lock'` (a directory)
  - Try `fs.mkdirSync(lockDir)` **without** `{ recursive: true }` — EEXIST means lock is held
  - On success: write a JSON info file inside lockDir containing `{ pid: process.pid, ts: Date.now() }`
  - On EEXIST: read the info file, check staleness:
    - If timestamp is older than `staleMs`, force-remove with `fs.rmSync(lockDir, { recursive: true, force: true })` and retry
    - If PID is dead (try `process.kill(pid, 0)` in try/catch — throws if PID not running), force-remove and retry
    - Otherwise, wait using a `Date.now()` polling loop for `retryDelay` ms, then retry
  - After all retries exhausted: throw Error with message including filePath and retry count
  - Return the lockDir path (needed by releaseLock)

  **`releaseLock(lockDir)`** — cleanup:
  - `fs.rmSync(lockDir, { recursive: true, force: true })` — best-effort, never throws

  **`atomicWriteFileSync(filePath, content, encoding)`** — temp+rename:
  - Compute `tmpPath = path.join(path.dirname(filePath), '.tmp-' + path.basename(filePath) + '.' + process.pid + '.' + Date.now())`
  - `fs.writeFileSync(tmpPath, content, encoding || 'utf-8')`
  - `fs.renameSync(tmpPath, filePath)`
  - On error in writeFileSync or renameSync: try `fs.unlinkSync(tmpPath)` in a catch block (cleanup orphan), then re-throw

  **`withFileLock(filePath, fn)`** — combined helper:
  - `const lockDir = acquireLock(filePath)`
  - `try { return fn(); } finally { releaseLock(lockDir); }`

  **3. Add a new section for command execution:**

  ```
  // ─── Git/CLI Detection ─────────────────────────────────────────────────────────
  ```

  **`execCommand(command, args, options)`** — spawnSync wrapper:
  - `options`: `{ cwd, timeout }` (optional)
  - Call `spawnSync(command, args, { cwd: options?.cwd || process.cwd(), encoding: 'utf-8', timeout: options?.timeout, stdio: ['pipe', 'pipe', 'pipe'] })`
  - Return `{ success: result.status === 0, exitCode: result.status, stdout: (result.stdout || '').trim(), stderr: (result.stderr || '').trim(), signal: result.signal || null, timedOut: result.error?.code === 'ETIMEDOUT' || false }`

  **`detectBuildCommand(cwd)`** — priority-ordered detection:
  - Check files in this order (first match wins):
    1. `package.json` — read and parse JSON; if `scripts.test` exists AND is NOT `"echo \"Error: no test specified\" && exit 1"` (the npm default), return `{ detected: true, command: 'npm test', source: 'package.json' }`
    2. `Cargo.toml` — if exists, return `{ detected: true, command: 'cargo test', source: 'Cargo.toml' }`
    3. `go.mod` — if exists, return `{ detected: true, command: 'go test ./...', source: 'go.mod' }`
    4. `pyproject.toml` — if exists, return `{ detected: true, command: 'pytest', source: 'pyproject.toml' }`
    5. `setup.py` — if exists, return `{ detected: true, command: 'pytest', source: 'setup.py' }`
    6. `Makefile` — if exists AND contains a line matching `/^test\s*:/m` regex, return `{ detected: true, command: 'make test', source: 'Makefile' }`
    7. `build.gradle` or `build.gradle.kts` — if exists, return `{ detected: true, command: './gradlew test', source: 'build.gradle' }`
    8. `pom.xml` — if exists, return `{ detected: true, command: 'mvn test', source: 'pom.xml' }`
  - If none match: return `{ detected: false, command: null, source: null }`
  - Use `safeReadFile` (already exists) for file reads, `fs.existsSync` for file checks

  **4. Extend `loadConfig` to include git fields:**

  Add these defaults to the `defaults` object in loadConfig:
  ```javascript
  git_flow: 'github',
  git_dev_branch: 'dev',
  git_build_gates_pre_pr: true,
  git_build_gates_pre_merge: true,
  git_build_gates_pre_main: true,
  git_build_command: null,
  git_build_timeout: 300,
  git_merge_strategy: 'merge',
  ```

  Add these lines to the return object (after the existing `brave_search` line):
  ```javascript
  git_flow: get('git_flow', { section: 'git', field: 'flow' }) ?? defaults.git_flow,
  git_dev_branch: get('git_dev_branch', { section: 'git', field: 'dev_branch' }) ?? defaults.git_dev_branch,
  git_build_gates_pre_pr: get('git_build_gates_pre_pr', { section: 'git', field: 'build_gates' }) !== undefined
    ? (typeof get('git_build_gates_pre_pr', { section: 'git', field: 'build_gates' }) === 'object'
      ? get('git_build_gates_pre_pr', { section: 'git', field: 'build_gates' }).pre_pr ?? defaults.git_build_gates_pre_pr
      : defaults.git_build_gates_pre_pr)
    : defaults.git_build_gates_pre_pr,
  ```

  Actually — the nested `build_gates` object in config makes the flat `get()` helper awkward. Use a simpler approach: after `const parsed = JSON.parse(raw)`, extract git fields directly:

  ```javascript
  const gitSection = parsed.git || {};
  const buildGates = gitSection.build_gates || {};
  ```

  Then in the return object:
  ```javascript
  git_flow: gitSection.flow ?? defaults.git_flow,
  git_dev_branch: gitSection.dev_branch ?? defaults.git_dev_branch,
  git_build_gates_pre_pr: buildGates.pre_pr ?? defaults.git_build_gates_pre_pr,
  git_build_gates_pre_merge: buildGates.pre_merge ?? defaults.git_build_gates_pre_merge,
  git_build_gates_pre_main: buildGates.pre_main ?? defaults.git_build_gates_pre_main,
  git_build_command: gitSection.build_command ?? defaults.git_build_command,
  git_build_timeout: gitSection.build_timeout ?? defaults.git_build_timeout,
  git_merge_strategy: gitSection.merge_strategy ?? defaults.git_merge_strategy,
  ```

  Also add these defaults to the `catch` block's `return defaults` (they are already in the defaults object, so this works automatically).

  **5. Add detection handler functions (before the CLI router):**

  **`cmdGitDetect(cwd, raw)`** — git version + gh CLI detection:
  - Call `execCommand('git', ['--version'], { cwd })` — parse version via regex `/(\d+\.\d+(?:\.\d+)?)/`
  - Compute `mergeTreeAvailable = major > 2 || (major === 2 && minor >= 38)`
  - Call `execCommand('gh', ['--version'], { cwd })` — parse version similarly
  - Output: `{ git: { version, merge_tree }, gh: { available, version } }`

  **`cmdGitDetectBuildCmd(cwd, raw)`** — build command detection with config override:
  - If `config.git_build_command` is truthy, return `{ detected: true, command: config.git_build_command, source: 'config', override: true }`
  - Otherwise call `detectBuildCommand(cwd)` and return the result
  - If not detected, return `{ detected: false, command: null, source: null, message: 'none detected' }`

  **6. Add initial `git` case to CLI router:**

  In the `switch(command)` block (before `default:`), add:
  ```javascript
  case 'git': {
    const subcommand = args[1];
    if (subcommand === 'detect') {
      cmdGitDetect(cwd, raw);
    } else if (subcommand === 'detect-build-cmd') {
      cmdGitDetectBuildCmd(cwd, raw);
    } else {
      error('Unknown git subcommand: ' + (subcommand || '(none)') + '. Available: detect, detect-build-cmd');
    }
    break;
  }
  ```

  **7. Update config.json template:**

  Add a `"git"` section to `hive/templates/config.json`:
  ```json
  "git": {
    "flow": "github",
    "dev_branch": "dev",
    "build_gates": {
      "pre_pr": true,
      "pre_merge": true,
      "pre_main": true
    },
    "build_command": null,
    "build_timeout": 300,
    "merge_strategy": "merge"
  }
  ```

  Place it after the `"safety"` section and before `"telemetry"`.

  **8. Sync installed copies:**
  - Copy `hive/bin/hive-tools.js` to `.claude/hive/bin/hive-tools.js`
  - Copy `hive/templates/config.json` to `.claude/hive/templates/config.json`
  - Verify with `wc -l` comparison.
  </action>
  <verify>
  Run the following verifications:

  1. `node hive/bin/hive-tools.js git detect` — must return JSON with git.version, git.merge_tree, gh.available fields
  2. `node hive/bin/hive-tools.js git detect-build-cmd` — in the project root (which has a package.json), should detect a build command or return detected:false
  3. Create a temp directory, write a package.json with `"test": "jest"`, run `node hive/bin/hive-tools.js git detect-build-cmd` from there — must return `npm test`
  4. Create a temp directory with no manifest files, run detect-build-cmd — must return `detected: false`
  5. `wc -l hive/bin/hive-tools.js .claude/hive/bin/hive-tools.js` — line counts must match
  6. `node -e "require('./hive/bin/hive-tools.js')" 2>&1` or just verify the file parses: `node -c hive/bin/hive-tools.js`
  7. Run existing tests: `cd hive/bin && node --test hive-tools.test.js` — all must pass (no regressions)
  </verify>
  <done>
  - `acquireLock`, `releaseLock`, `atomicWriteFileSync`, `withFileLock` exist and are callable
  - `execCommand` wraps spawnSync with structured returns (no exceptions on non-zero exit)
  - `loadConfig` returns git_flow, git_dev_branch, git_build_gates_*, git_build_command, git_build_timeout, git_merge_strategy with correct defaults
  - `detectBuildCommand` detects 8 project types and handles npm default placeholder
  - `cmdGitDetect` and `cmdGitDetectBuildCmd` are routed via CLI and return structured JSON
  - config.json template has a `git` section with all fields
  - Source and installed copies are in sync
  - All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for safety primitives, config extension, and detection functions</name>
  <files>
    hive/bin/hive-tools.test.js
    .claude/hive/bin/hive-tools.test.js
  </files>
  <action>
  Add new test blocks to `hive/bin/hive-tools.test.js`, following the existing pattern of `createTempProject()` / `cleanup()` with `beforeEach` / `afterEach`.

  **Test group 1: `describe('git detect command')`**

  - `test('detect returns git version and gh availability')` — run `git detect`, parse JSON, assert `result.git.version` is a string matching `/\d+\.\d+/`, assert `result.git.merge_tree` is boolean, assert `result.gh` has `available` field
  - `test('detect returns structured JSON via --raw')` — run `git detect --raw`, verify it produces output (raw mode returns rawValue string)

  **Test group 2: `describe('git detect-build-cmd command')`**

  - `test('detects npm test in Node project')` — create temp dir, write `package.json` with `{ "scripts": { "test": "jest" } }`, run `git detect-build-cmd`, assert `command === 'npm test'`, `source === 'package.json'`, `detected === true`
  - `test('skips npm default placeholder test script')` — create temp dir, write `package.json` with `{ "scripts": { "test": "echo \"Error: no test specified\" && exit 1" } }`, run `git detect-build-cmd`, assert `detected === false`
  - `test('detects cargo test for Rust projects')` — create temp dir, write empty `Cargo.toml`, run `git detect-build-cmd`, assert `command === 'cargo test'`
  - `test('returns none detected for empty project')` — create temp dir (no manifest files), run `git detect-build-cmd`, assert `detected === false`, `command === null`
  - `test('config override takes precedence')` — create temp dir with `.planning/config.json` containing `{ "git": { "build_command": "make custom-test" } }`, run `git detect-build-cmd`, assert `command === 'make custom-test'`, `override === true`

  **Test group 3: `describe('loadConfig git fields')`**

  - `test('returns git defaults when no git section')` — create temp dir with `.planning/config.json` containing `{}`, run `node -e "const lc = require('...hive-tools.js'); ..."` — actually, since loadConfig is not exported, test via a subcommand that reads config. Alternative: test indirectly via `git detect-build-cmd` behavior with `git.flow: "none"` config (but that subcommand does not check flow). Best approach: verify defaults by checking that `git detect` works even when config has no git section (it doesn't read config, so this is implicit). Instead, add a direct test: write a small script that requires hive-tools.js — but it calls main() on require. So test loadConfig indirectly through the subcommands in Plan 2. For now, test config override on detect-build-cmd (already covered above).

  **Test group 4: `describe('atomicWriteFileSync')`**

  Since the function is internal (not exported), test it indirectly. The simplest approach: use `state update` or another command that will be updated to use atomic writes. For now, verify no temp files are orphaned after writes by checking `ls` of directory. OR — add a `test-atomic-write` hidden subcommand for testing purposes. The cleanest approach: test the safety primitives in Plan 2 when git subcommands use them, and for now verify the functions parse correctly with `node -c hive-tools.js`.

  Actually, the most pragmatic approach: add a test that directly calls the functions by extracting them. Since hive-tools.js is a CLI script that calls `main()` at the end, direct require is not practical. Instead, add CLI-level tests that exercise the functions through commands that use them. For Plan 1, the detection commands don't use locks/atomic writes, so defer those integration tests to Plan 2.

  **Sync:** Copy updated test file to `.claude/hive/bin/hive-tools.test.js`.
  </action>
  <verify>
  Run the full test suite:
  ```bash
  cd hive/bin && node --test hive-tools.test.js
  ```
  All tests must pass, including new ones. No regressions in existing tests.
  </verify>
  <done>
  - New tests verify git detect returns structured version info
  - New tests verify detect-build-cmd detects npm/cargo/none and handles npm placeholder
  - New tests verify config override takes precedence
  - All existing tests still pass
  - Source and installed test files in sync
  </done>
</task>

</tasks>

<verification>
1. `node hive/bin/hive-tools.js git detect` returns valid JSON with git version and gh availability
2. `node hive/bin/hive-tools.js git detect-build-cmd` returns valid JSON with detection result
3. `node -c hive/bin/hive-tools.js` succeeds (no syntax errors)
4. `cd hive/bin && node --test hive-tools.test.js` — all tests pass
5. `wc -l hive/bin/hive-tools.js .claude/hive/bin/hive-tools.js` — line counts match
6. `diff hive/templates/config.json .claude/hive/templates/config.json` — no diff
7. Config.json template contains `"git"` section with flow, dev_branch, build_gates, build_command, build_timeout, merge_strategy
</verification>

<success_criteria>
- Safety primitives (acquireLock, releaseLock, atomicWriteFileSync, withFileLock) exist in hive-tools.js
- execCommand wraps spawnSync with structured returns
- loadConfig includes all git_* fields with sensible defaults
- detectBuildCommand handles 8 project types and npm placeholder edge case
- Two detection subcommands (detect, detect-build-cmd) work via CLI
- config.json template has git section
- All tests pass, no regressions
- Source and installed copies synced
</success_criteria>

<output>
After completion, create `.planning/phases/08-safety-configuration/08-01-SUMMARY.md`
</output>
