---
phase: 08-safety-configuration
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - hive/bin/hive-tools.js
  - hive/bin/hive-tools.test.js
  - .claude/hive/bin/hive-tools.js
  - .claude/hive/bin/hive-tools.test.js
autonomous: true

must_haves:
  truths:
    - "Running git create-dev-branch creates a branch named per config.git.dev_branch and returns structured JSON"
    - "Running git create-plan-branch --name hive/08-01-safety creates a branch from dev and returns structured JSON"
    - "Running git run-build-gate executes the detected or configured build command and returns pass/fail JSON with stdout/stderr"
    - "Running git create-pr creates a GitHub PR via gh CLI and returns the PR URL in structured JSON"
    - "Running git self-merge-pr merges a PR with the configured merge strategy and returns structured JSON"
    - "Running git merge-dev-to-main merges dev into main with --no-ff and returns structured JSON"
    - "Running git check-conflicts checks for merge conflicts without modifying worktree and returns structured JSON"
    - "Running git delete-plan-branch deletes a local branch and returns structured JSON"
    - "Running git current-branch returns the current git branch name as structured JSON"
    - "All git subcommands return {success: true, skipped: true, reason: 'git.flow is none'} when git.flow is 'none'"
    - "Build gate respects configured timeout (config seconds * 1000 for spawnSync milliseconds)"
  artifacts:
    - path: "hive/bin/hive-tools.js"
      provides: "10 git subcommand handlers + expanded CLI router"
      contains: "cmdGitCreateDevBranch"
    - path: "hive/bin/hive-tools.test.js"
      provides: "Tests for all git subcommands"
      contains: "git subcommands"
  key_links:
    - from: "hive/bin/hive-tools.js (CLI router git case)"
      to: "cmdGit* handler functions"
      via: "subcommand dispatch"
      pattern: "case 'git'.*subcommand"
    - from: "cmdGit* handlers"
      to: "execCommand"
      via: "spawnSync wrapper for git/gh commands"
      pattern: "execCommand\\('git'"
    - from: "cmdGit* handlers"
      to: "loadConfig git_flow check"
      via: "flow bypass pattern"
      pattern: "git_flow.*none.*skipped"
---

<objective>
Implement all ~10 git subcommands in hive-tools.js and wire them through the CLI router with comprehensive tests.

Purpose: Complete INTG-04 (git subcommands) and SETUP-04 (flow bypass). Each subcommand is a thin handler that uses execCommand (from Plan 1) to run git/gh operations and returns structured JSON. All subcommands check config.git_flow and skip when set to "none".

Output: Fully functional git subcommand group in hive-tools.js with tests for all subcommands. Later phases (9-11) compose these primitives into branch lifecycle, PR workflows, and repo manager features.
</objective>

<execution_context>
@./.claude/hive/workflows/execute-plan.md
@./.claude/hive/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-safety-configuration/08-RESEARCH.md
@.planning/phases/08-safety-configuration/08-01-SUMMARY.md
@hive/bin/hive-tools.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement git subcommand handlers and expand CLI router</name>
  <files>
    hive/bin/hive-tools.js
    .claude/hive/bin/hive-tools.js
  </files>
  <action>
  Add a new section in hive-tools.js after the Git/CLI Detection section (from Plan 1):

  ```
  // --- Git Subcommands -------------------------------------------------------
  ```

  **Flow bypass pattern -- every handler (except current-branch) starts with:**
  ```javascript
  const config = loadConfig(cwd);
  if (config.git_flow === 'none') {
    output({ success: true, skipped: true, reason: 'git.flow is none' }, raw, 'skipped');
    return;
  }
  ```

  **Implement these handlers:**

  **1. cmdGitCurrentBranch(cwd, raw)**
  - Run execCommand('git', ['rev-parse', '--abbrev-ref', 'HEAD'], { cwd })
  - Output: { success, branch: stdout } or { success: false, error: stderr }
  - This one does NOT need the flow bypass (it is informational, not a workflow action)

  **2. cmdGitCreateDevBranch(cwd, raw)**
  - Flow bypass check
  - devBranch = config.git_dev_branch || 'dev'
  - Check if branch exists: execCommand('git', ['rev-parse', '--verify', devBranch], { cwd })
  - If exists: output { success: true, branch: devBranch, created: false, reason: 'already_exists' }
  - If not: execCommand('git', ['checkout', '-b', devBranch], { cwd })
  - On success: output { success: true, branch: devBranch, created: true }
  - On failure: output { success: false, error: stderr }

  **3. cmdGitCreatePlanBranch(cwd, branchName, raw)**
  - Flow bypass check
  - If !branchName: output { success: false, error: 'branch name required (--name <branch>)' }
  - devBranch = config.git_dev_branch || 'dev'
  - First check if dev branch exists: execCommand('git', ['rev-parse', '--verify', devBranch], { cwd })
  - If dev branch does not exist: output { success: false, error: 'dev branch "' + devBranch + '" does not exist. Run git create-dev-branch first.' }
  - Create branch from dev: execCommand('git', ['checkout', '-b', branchName, devBranch], { cwd })
  - On success: output { success: true, branch: branchName, base: devBranch, created: true }
  - On failure: output { success: false, error: stderr }

  **4. cmdGitRunBuildGate(cwd, raw)**
  - Flow bypass check
  - Get build command: config.git_build_command || detectBuildCommand(cwd).command
  - If no build command: output { success: true, skipped: true, reason: 'no build command detected' }
  - Compute timeout: const timeoutMs = (config.git_build_timeout || 300) * 1000 (IMPORTANT: seconds to milliseconds)
  - Split command: const parts = buildCmd.split(/\s+/)
  - Run: execCommand(parts[0], parts.slice(1), { cwd, timeout: timeoutMs })
  - Output: { success: result.success, command: buildCmd, exitCode: result.exitCode, timedOut: result.timedOut || false, stdout: result.stdout.slice(0, 2000), stderr: result.stderr.slice(0, 2000) }

  **5. cmdGitCreatePr(cwd, options, raw)**
  - Flow bypass check
  - Parse options: base (required), title (required), body (optional, default '')
  - If !base || !title: output { success: false, error: 'base and title required (--base <branch> --title <title>)' }
  - Build args: ['pr', 'create', '--base', base, '--title', title, '--body', body || '']
  - Run: execCommand('gh', args, { cwd })
  - Parse PR URL from stdout (gh pr create outputs the URL on success)
  - Output: { success: result.success, pr_url: result.stdout.trim(), base, title } or { success: false, error: result.stderr }

  **6. cmdGitSelfMergePr(cwd, prNumber, raw)**
  - Flow bypass check
  - If !prNumber: output { success: false, error: 'PR number required' }
  - mergeStrategy = config.git_merge_strategy || 'merge'
  - Build args: ['pr', 'merge', prNumber, '--' + mergeStrategy, '--delete-branch']
  - Run: execCommand('gh', args, { cwd })
  - Output: { success: result.success, pr: prNumber, strategy: mergeStrategy, merged: result.success } or { success: false, error: result.stderr }

  **7. cmdGitMergeDevToMain(cwd, raw)**
  - Flow bypass check
  - devBranch = config.git_dev_branch || 'dev'
  - First checkout main: execCommand('git', ['checkout', 'main'], { cwd })
  - If checkout fails: try master as fallback: execCommand('git', ['checkout', 'master'], { cwd })
  - If both fail: output { success: false, error: 'Could not checkout main or master branch' }
  - Merge with no-ff: execCommand('git', ['merge', '--no-ff', devBranch, '-m', 'Merge ' + devBranch + ' into ' + mainBranch], { cwd })
  - On success: output { success: true, from: devBranch, to: mainBranch, strategy: 'no-ff' }
  - On failure: abort merge execCommand('git', ['merge', '--abort'], { cwd }), then output { success: false, error: result.stderr }

  **8. cmdGitCheckConflicts(cwd, branchName, raw)**
  - Flow bypass check
  - If !branchName: output { success: false, error: 'branch name required (--branch <branch>)' }
  - devBranch = config.git_dev_branch || 'dev'
  - Check git version for merge-tree availability: parse version, check if >= 2.38
  - If merge-tree available: execCommand('git', ['merge-tree', '--write-tree', '--no-messages', devBranch, branchName], { cwd })
    - Exit code 0 = no conflicts: output { success: true, has_conflicts: false, method: 'merge-tree' }
    - Non-zero = conflicts detected: output { success: true, has_conflicts: true, method: 'merge-tree' }
  - If merge-tree NOT available (git < 2.38): use dry-run merge + abort fallback
    - output { success: true, has_conflicts: !result.success, method: 'merge-dry-run' }
  - On any unexpected error: output { success: false, error: stderr }

  **9. cmdGitDeletePlanBranch(cwd, branchName, raw)**
  - Flow bypass check
  - If !branchName: output { success: false, error: 'branch name required' }
  - Safety: refuse to delete main, master, or the configured dev_branch: output { success: false, error: 'Cannot delete protected branch: ' + branchName }
  - Delete local with -d (safe delete, requires merged): execCommand('git', ['branch', '-d', branchName], { cwd })
  - If -d fails: output { success: false, error: 'Branch not fully merged. Use git branch -D manually if intended.', branch: branchName }
  - On success: output { success: true, branch: branchName, deleted: true }

  **10. Expand CLI router git case:**

  Update the case 'git': block (from Plan 1, which has detect and detect-build-cmd) to add all new subcommands. The full routing block should handle: create-dev-branch, create-plan-branch, detect-build-cmd, run-build-gate, create-pr, self-merge-pr, merge-dev-to-main, check-conflicts, delete-plan-branch, current-branch, detect.

  Parse flags for create-pr (--base, --title, --body), create-plan-branch (--name), check-conflicts (--branch) using args.indexOf pattern matching the existing convention.

  Also update the usage string in the if (!command) block to include git in the list.

  **11. Sync installed copy:**
  - Copy hive/bin/hive-tools.js to .claude/hive/bin/hive-tools.js
  - Verify with wc -l comparison
  </action>
  <verify>
  Test each subcommand manually in the project repo (which is a git repo):

  1. node hive/bin/hive-tools.js git current-branch -- returns JSON with branch name
  2. node hive/bin/hive-tools.js git detect -- returns git/gh info
  3. node hive/bin/hive-tools.js git detect-build-cmd -- returns detection result
  4. node -c hive/bin/hive-tools.js -- no syntax errors
  5. wc -l hive/bin/hive-tools.js .claude/hive/bin/hive-tools.js -- match
  6. Verify flow bypass: create temp .planning/config.json with {"git":{"flow":"none"}}, run any git subcommand, verify skipped: true in output
  </verify>
  <done>
  - All 10 git subcommands implemented: create-dev-branch, create-plan-branch, detect-build-cmd, run-build-gate, create-pr, self-merge-pr, merge-dev-to-main, check-conflicts, delete-plan-branch, current-branch (plus detect from Plan 1)
  - CLI router dispatches all subcommands correctly
  - All subcommands return structured JSON with success/error status
  - Flow bypass works for all subcommands (except current-branch which is informational)
  - Source and installed copies synced
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for all git subcommands</name>
  <files>
    hive/bin/hive-tools.test.js
    .claude/hive/bin/hive-tools.test.js
  </files>
  <action>
  Add test groups to hive/bin/hive-tools.test.js. Tests that require git operations need a temp git repo initialized in beforeEach.

  **Test group: describe('git subcommands')**

  Use a shared beforeEach that creates a temp project AND initializes a git repo:
  ```javascript
  let tmpDir;
  beforeEach(() => {
    tmpDir = createTempProject();
    // Initialize git repo with test identity
    execSync('git init && git add -A && git commit --allow-empty -m "init"', {
      cwd: tmpDir, stdio: 'pipe',
      env: { ...process.env, GIT_AUTHOR_NAME: 'test', GIT_AUTHOR_EMAIL: 'test@test.com',
             GIT_COMMITTER_NAME: 'test', GIT_COMMITTER_EMAIL: 'test@test.com' }
    });
  });
  afterEach(() => { cleanup(tmpDir); });
  ```

  **Tests:**

  1. test('current-branch returns branch name') -- run git current-branch, parse JSON, assert success === true, assert branch is a string

  2. test('create-dev-branch creates new branch') -- run git create-dev-branch, parse JSON, assert success === true, created === true, branch === 'dev'

  3. test('create-dev-branch reports already exists') -- run create-dev-branch twice, second call should return created === false, reason === 'already_exists'

  4. test('create-plan-branch creates branch from dev') -- first run create-dev-branch, then run git create-plan-branch --name hive/08-01-safety, assert success === true, branch === 'hive/08-01-safety', base === 'dev'

  5. test('create-plan-branch fails without dev branch') -- run git create-plan-branch --name hive/test without creating dev first, assert success === false

  6. test('create-plan-branch fails without name') -- run git create-plan-branch (no --name), assert success === false

  7. test('delete-plan-branch deletes branch') -- create dev, create plan branch hive/test, switch back to dev (via execSync git checkout dev), run git delete-plan-branch hive/test, assert success === true, deleted === true

  8. test('delete-plan-branch refuses protected branches') -- try to delete main or dev, assert success === false with error about protected branch

  9. test('run-build-gate skips when no build command') -- temp dir with no manifest files, run git run-build-gate, assert skipped === true

  10. test('run-build-gate runs detected command') -- create temp dir with package.json having "test": "node -e \"process.exit(0)\"", run git run-build-gate, assert success === true

  11. test('all git subcommands skip when flow is none') -- write config with {"git":{"flow":"none"}}, run each subcommand that has flow bypass, assert all return skipped === true. Test at least: create-dev-branch, create-plan-branch --name test, run-build-gate, delete-plan-branch test

  12. test('detect-build-cmd detects go test for Go projects') -- create temp dir, write empty go.mod, run git detect-build-cmd, assert command === 'go test ./...'

  13. test('check-conflicts requires branch name') -- run git check-conflicts without --branch, assert success === false

  **Sync:** Copy updated test file to .claude/hive/bin/hive-tools.test.js.
  </action>
  <verify>
  ```bash
  cd hive/bin && node --test hive-tools.test.js
  ```
  All tests pass. Verify:
  - New git subcommand tests pass
  - Existing tests still pass (no regressions)
  - wc -l hive/bin/hive-tools.test.js .claude/hive/bin/hive-tools.test.js -- match
  </verify>
  <done>
  - 13+ tests cover all git subcommands
  - Flow bypass tested for all applicable subcommands
  - Branch creation/deletion lifecycle tested
  - Build gate skip and run tested
  - Protected branch safety tested
  - Error cases tested (missing args, missing dev branch)
  - All existing tests pass
  - Source and installed test files synced
  </done>
</task>

</tasks>

<verification>
1. node hive/bin/hive-tools.js git current-branch -- returns current branch as JSON
2. node hive/bin/hive-tools.js git detect -- returns git and gh info
3. node hive/bin/hive-tools.js git detect-build-cmd -- returns detection result
4. All git subcommands available: create-dev-branch, create-plan-branch, detect-build-cmd, run-build-gate, create-pr, self-merge-pr, merge-dev-to-main, check-conflicts, delete-plan-branch, current-branch, detect
5. cd hive/bin && node --test hive-tools.test.js -- all tests pass
6. wc -l hive/bin/hive-tools.js .claude/hive/bin/hive-tools.js -- match
7. wc -l hive/bin/hive-tools.test.js .claude/hive/bin/hive-tools.test.js -- match
8. Flow bypass verified: config with git.flow: "none" causes all workflow subcommands to return skipped: true
</verification>

<success_criteria>
- All 10 git subcommands implemented and routed (INTG-04 complete)
- All subcommands return structured JSON with success/error (Phase 8 success criterion 5)
- Flow bypass works for all workflow subcommands (SETUP-04 complete)
- Build gate respects timeout with seconds-to-milliseconds conversion
- Protected branch safety prevents deletion of main/master/dev
- Comprehensive test coverage with 13+ test cases
- Source and installed copies synced
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/08-safety-configuration/08-02-SUMMARY.md`
</output>
